#!/usr/bin/env python3
"""
kfg - Keep Fucking Going utility
Terminal window manager with socket-based command injection
"""

import sys
import os
import socket
import subprocess
import json
import time
import signal
import tempfile
import glob
import re
from pathlib import Path


SOCKET_PATH = os.path.expanduser("~/.kfg_socket")
PID_FILE = os.path.expanduser("~/.kfg_pid")
CONFIG_FILE = os.path.expanduser("~/.kfg_config.json")

# Default configuration
DEFAULT_CONFIG = {
    "continue_phrase": "keep fucking going!",
    "polite_question": "Is there anything you can continue working on? (Y/N)",
    "delays": {
        "initial": 0.8,
        "between_commands": 0.4,
        "final": 0.5
    }
}


def load_config():
    """Load configuration from file or return defaults"""
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Merge with defaults to ensure all keys exist
                merged_config = DEFAULT_CONFIG.copy()
                merged_config.update(config)
                return merged_config
    except Exception as e:
        print(f"Error loading config: {e}, using defaults")
    
    return DEFAULT_CONFIG.copy()


def save_config(config):
    """Save configuration to file"""
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print(f"Error saving config: {e}")
        return False


def get_terminal_windows():
    """Get list of Terminal windows using AppleScript"""
    try:
        result = subprocess.run([
            'osascript', '-e', 
            'tell application "Terminal" to get name of every window'
        ], capture_output=True, text=True, check=True)
        
        windows = result.stdout.strip().split(', ')
        return [w.strip() for w in windows if w.strip()]
    except subprocess.CalledProcessError:
        print("Error: Could not get Terminal windows. Is Terminal.app running?")
        return []


def select_terminal_window(windows):
    """Display menu for terminal window selection"""
    if not windows:
        print("No terminal windows found!")
        return None
    
    print("\nAvailable terminal windows:")
    for i, window in enumerate(windows, 1):
        print(f"{i:2d}. {window}")
    
    while True:
        try:
            choice = input(f"\nSelect terminal window (1-{len(windows)}): ").strip()
            idx = int(choice) - 1
            if 0 <= idx < len(windows):
                return idx
            else:
                print(f"Please enter a number between 1 and {len(windows)}")
        except (ValueError, KeyboardInterrupt):
            print("\nExiting...")
            return None


def send_to_terminal(window_index, command):
    """Send command to specific terminal window using AppleScript"""
    try:
        if command == "":
            # Send enter key using keystroke
            applescript = f'''
            tell application "Terminal"
                activate
                set targetWindow to window {window_index + 1}
                set frontmost of targetWindow to true
                tell application "System Events"
                    keystroke return
                end tell
            end tell
            '''
        else:
            # Send regular command
            applescript = f'''
            tell application "Terminal"
                activate
                set targetWindow to window {window_index + 1}
                set frontmost of targetWindow to true
                do script "{command}" in targetWindow
            end tell
            '''
        
        subprocess.run(['osascript', '-e', applescript], check=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error sending command to terminal: {e}")
        return False


def get_terminal_last_line(window_index):
    """Get the entire terminal output from specific terminal window using AppleScript"""
    try:
        applescript = f'''
        tell application "Terminal"
            set targetWindow to window {window_index + 1}
            set windowHistory to history of targetWindow
            return windowHistory
        end tell
        '''
        
        result = subprocess.run(['osascript', '-e', applescript], 
                              capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error reading from terminal: {e}")
        return None


def get_last_claude_response(project_dir=None):
    """Get the last Claude response from the project files"""
    try:
        # Use provided project directory or construct from current working directory
        if project_dir is None:
            cwd = os.getcwd()
            project_name = cwd.replace('/', '-')
            claude_project_dir = os.path.expanduser(f"~/.claude/projects/{project_name}")
        else:
            # Convert raw project directory to Claude projects format
            project_name = project_dir.replace('/', '-')
            claude_project_dir = os.path.expanduser(f"~/.claude/projects/{project_name}")
        
        if not os.path.exists(claude_project_dir):
            print(f"Claude project directory not found: {claude_project_dir}")
            return None
        
        # Find the most recent JSONL file
        try:
            jsonl_files = glob.glob(os.path.join(claude_project_dir, "*.jsonl"))
        except Exception as e:
            print(f"Error finding JSONL files: {e}")
            return None
            
        if not jsonl_files:
            print("No conversation files found in Claude project directory")
            return None
        
        # Get the most recently modified file
        try:
            latest_file = max(jsonl_files, key=os.path.getmtime)
            print(f"Reading from: {latest_file}")
        except Exception as e:
            print(f"Error finding latest file: {e}")
            return None
        
        # Read the file and find the last assistant message
        last_assistant_response = None
        try:
            with open(latest_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                        
                    try:
                        data = json.loads(line)
                        if (data.get('type') == 'assistant' and 
                            'message' in data and 
                            'content' in data['message']):
                            
                            # Extract text content from the message
                            content = data['message']['content']
                            if isinstance(content, list):
                                # Find text content in the array
                                for item in content:
                                    if isinstance(item, dict) and item.get('type') == 'text':
                                        text_content = item.get('text', '')
                                        if text_content.strip():
                                            last_assistant_response = text_content
                                        break
                            elif isinstance(content, str) and content.strip():
                                last_assistant_response = content
                    except json.JSONDecodeError as e:
                        # Skip malformed JSON lines
                        continue
                    except KeyError:
                        # Skip lines with unexpected structure
                        continue
        except IOError as e:
            print(f"Error reading Claude project file: {e}")
            return None
        except UnicodeDecodeError as e:
            print(f"Error decoding Claude project file: {e}")
            return None
        
        return last_assistant_response
        
    except Exception as e:
        print(f"Unexpected error getting last Claude response: {e}")
        return None



def get_current_window_index():
    """Get the currently selected terminal window index from stored state"""
    try:
        state_file = os.path.expanduser("~/.kfg_state")
        if os.path.exists(state_file):
            with open(state_file, 'r') as f:
                data = json.load(f)
                return data.get('window_index')
    except:
        pass
    return None


def save_current_window_index(window_index):
    """Save the currently selected terminal window index"""
    try:
        state_file = os.path.expanduser("~/.kfg_state")
        with open(state_file, 'w') as f:
            json.dump({'window_index': window_index}, f)
    except:
        pass


def add_claude_hook():
    """Add kfg trigger hook to Claude settings"""
    # Look for .claude directory in current working directory
    claude_dir = ".claude"
    if not os.path.exists(claude_dir):
        print("No .claude directory found in current directory")
        return False
    
    # Check for settings.local.json first, then settings.json
    settings_files = ["settings.local.json", "settings.json"]
    settings_path = None
    
    for filename in settings_files:
        path = os.path.join(claude_dir, filename)
        if os.path.exists(path):
            settings_path = path
            break
    
    if not settings_path:
        # Create settings.local.json if neither exists
        settings_path = os.path.join(claude_dir, "settings.local.json")
        settings_data = {
            "$schema": "https://json.schemastore.org/claude-code-settings.json",
            "hooks": {}
        }
    else:
        # Load existing settings
        try:
            with open(settings_path, 'r') as f:
                settings_data = json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Error reading {settings_path}: {e}")
            return False
    
    # Ensure hooks section exists
    if "hooks" not in settings_data:
        settings_data["hooks"] = {}
    
    # Ensure Stop hooks section exists
    if "Stop" not in settings_data["hooks"]:
        settings_data["hooks"]["Stop"] = []
    
    # Check if kfg hook already exists
    kfg_hook = {
        "type": "command",
        "command": "kfg trigger"
    }
    
    for hook_entry in settings_data["hooks"]["Stop"]:
        if "hooks" in hook_entry:
            for hook in hook_entry["hooks"]:
                if hook.get("command") == "kfg trigger":
                    print("kfg trigger hook already exists in Claude settings")
                    return True
    
    # Add the kfg hook
    kfg_hook_entry = {
        "matcher": "*",
        "hooks": [kfg_hook]
    }
    
    settings_data["hooks"]["Stop"].append(kfg_hook_entry)
    
    # Write back to file
    try:
        with open(settings_path, 'w') as f:
            json.dump(settings_data, f, indent=2)
        
        print(f"âœ… Added kfg trigger hook to {settings_path}")
        print("Claude will now trigger kfg when stopping tasks")
        return True
        
    except IOError as e:
        print(f"Error writing to {settings_path}: {e}")
        return False


def cleanup():
    """Clean up socket and PID files"""
    try:
        if os.path.exists(SOCKET_PATH):
            os.unlink(SOCKET_PATH)
        if os.path.exists(PID_FILE):
            os.unlink(PID_FILE)
        state_file = os.path.expanduser("~/.kfg_state")
        if os.path.exists(state_file):
            os.unlink(state_file)
    except OSError:
        pass


def signal_handler(signum, frame):
    """Handle termination signals"""
    print(f"\nReceived signal {signum}, cleaning up...")
    cleanup()
    sys.exit(0)


def is_daemon_running():
    """Check if kfg daemon is already running"""
    if not os.path.exists(PID_FILE):
        return False
    
    try:
        with open(PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        # Check if process is still running
        os.kill(pid, 0)
        return True
    except (OSError, ValueError):
        # PID file exists but process is dead
        cleanup()
        return False


def start_daemon(window_index):
    """Start the socket server daemon"""
    # Load configuration
    config = load_config()
    
    # Set up signal handlers
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    # Clean up any existing socket
    cleanup()
    
    # Save window index for later use
    save_current_window_index(window_index)
    
    # Write PID file
    with open(PID_FILE, 'w') as f:
        f.write(str(os.getpid()))
    
    # Create Unix domain socket
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(SOCKET_PATH)
    sock.listen(5)
    
    print(f"kfg daemon started (PID: {os.getpid()})")
    print(f"Listening on {SOCKET_PATH}")
    print("Send requests to trigger 'keep fucking going!' in terminal")
    print("Press Ctrl+C to stop\n")
    
    try:
        while True:
            conn, addr = sock.accept()
            try:
                data = conn.recv(1024).decode('utf-8').strip()
                if data:
                    print(f"Received trigger request: {data}")
                    
                    # Parse project directory from trigger message
                    project_dir = None
                    if data.startswith('trigger:'):
                        project_dir = data.split(':', 1)[1]
                        print(f"Using project directory: {project_dir}")
                    
                    # Get the last Claude response from project files
                    last_claude_response = get_last_claude_response(project_dir)
                    if last_claude_response is None:
                        last_claude_response = ""
                    
                    # Show truncated response for debugging
                    if last_claude_response:
                        debug_response = last_claude_response.replace('\n', ' ').strip()
                        if len(debug_response) > 100:
                            debug_response = debug_response[:100] + "..."
                        print(f"Last Claude response: '{debug_response}'")
                    else:
                        print("Last Claude response: (empty or not found)")
                    
                    # Check response and decide action with improved Y/N detection
                    response_lower = last_claude_response.lower() if last_claude_response else ""
                    
                    # Look for clear Y or N responses (standalone or at word boundaries)
                    
                    # Check for standalone Y, Yes, N, No at the beginning or as separate words
                    y_pattern = r'\b(y|yes)\b'
                    n_pattern = r'\b(n|no)\b'
                    
                    has_y = bool(re.search(y_pattern, response_lower))
                    has_n = bool(re.search(n_pattern, response_lower))
                    
                    # Special case: if response is just "Y" or just "N", prioritize that
                    trimmed_response = response_lower.strip()
                    if trimmed_response in ['y', 'yes']:
                        has_y = True
                        has_n = False
                    elif trimmed_response in ['n', 'no']:
                        has_n = True
                        has_y = False
                    
                    if has_n and not has_y:
                        # Claude said No - do nothing
                        print("Claude responded with 'N/No' - doing nothing")
                        conn.send(b"NO_ACTION\n")
                    elif has_y and not has_n:
                        # Claude said Yes - execute "keep fucking going!" sequence
                        print("Claude responded with 'Y/Yes' - executing 'keep fucking going!' sequence")
                        
                        # Initial delay to let terminal activate
                        time.sleep(config["delays"]["initial"])
                        
                        # Send enter key first
                        send_to_terminal(window_index, "")
                        time.sleep(config["delays"]["between_commands"])
                        
                        # Send configured continue phrase
                        send_to_terminal(window_index, config["continue_phrase"])
                        time.sleep(config["delays"]["between_commands"])
                        
                        # Send final enter
                        send_to_terminal(window_index, "")
                        time.sleep(config["delays"]["final"])
                        
                        # Reselect terminal and send another enter
                        send_to_terminal(window_index, "")
                        
                        conn.send(b"KEEP_GOING\n")
                        print(f"Sent '{config['continue_phrase']}' to terminal")
                    else:
                        # No clear Y/N found - ask politely
                        print("No clear Y/N response found - asking politely")
                        
                        # Initial delay to let terminal activate
                        time.sleep(config["delays"]["initial"])
                        
                        # Send enter key first
                        send_to_terminal(window_index, "")
                        time.sleep(config["delays"]["between_commands"])
                        
                        # Send configured polite question
                        send_to_terminal(window_index, config["polite_question"])
                        time.sleep(config["delays"]["between_commands"])
                        
                        # Send final enter
                        send_to_terminal(window_index, "")
                        time.sleep(config["delays"]["final"])
                        
                        # Reselect terminal and send another enter
                        send_to_terminal(window_index, "")
                        
                        conn.send(b"ASKED_POLITELY\n")
                        print("Asked Claude politely to continue")
            except Exception as e:
                print(f"Error handling request: {e}")
            finally:
                conn.close()
    except KeyboardInterrupt:
        pass
    finally:
        sock.close()
        cleanup()
        print("kfg daemon stopped")


def send_trigger(project_dir=None):
    """Send trigger to running daemon"""
    if not is_daemon_running():
        print("kfg daemon is not running. Start it first with 'kfg'")
        return False
    
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(SOCKET_PATH)
        
        # Send trigger with optional project directory
        message = "trigger"
        if project_dir:
            message = f"trigger:{project_dir}"
        
        sock.send(f"{message}\n".encode())
        response = sock.recv(1024).decode('utf-8').strip()
        sock.close()
        
        print(f"Trigger sent: {response}")
        return True
    except Exception as e:
        print(f"Error sending trigger: {e}")
        return False


def stop_daemon():
    """Stop running daemon"""
    if not is_daemon_running():
        print("kfg daemon is not running")
        return
    
    try:
        with open(PID_FILE, 'r') as f:
            pid = int(f.read().strip())
        
        os.kill(pid, signal.SIGTERM)
        time.sleep(1)
        
        if not is_daemon_running():
            print("kfg daemon stopped")
        else:
            print("Failed to stop daemon")
    except Exception as e:
        print(f"Error stopping daemon: {e}")


def show_status():
    """Show daemon status"""
    if is_daemon_running():
        with open(PID_FILE, 'r') as f:
            pid = f.read().strip()
        print(f"kfg daemon is running (PID: {pid})")
        print(f"Socket: {SOCKET_PATH}")
    else:
        print("kfg daemon is not running")


def main():
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        
        if cmd == "trigger":
            # Check if CLAUDE_PROJECT_DIR is available from the hook
            project_dir = os.environ.get('CLAUDE_PROJECT_DIR')
            print(f"Project directory: {project_dir}")
            send_trigger(project_dir)
        elif cmd == "stop":
            stop_daemon()
        elif cmd == "status":
            show_status()
        elif cmd == "last-line":
            # Get the last Claude response from project files
            last_response = get_last_claude_response()
            if last_response is not None:
                print(last_response)
            else:
                print("Error: Could not read Claude response from project files")
        elif cmd == "add":
            add_claude_hook()
        elif cmd == "config":
            config = load_config()
            if len(sys.argv) == 2:
                # Show current config
                print("Current configuration:")
                print(json.dumps(config, indent=2))
            elif len(sys.argv) >= 5 and sys.argv[2] == "set":
                # Set a config value: kfg config set continue_phrase "keep going!"
                key = sys.argv[3]
                value = sys.argv[4]
                
                # Parse dotted keys like delays.initial
                keys = key.split('.')
                target = config
                for k in keys[:-1]:
                    if k not in target:
                        target[k] = {}
                    target = target[k]
                
                # Try to parse as number, boolean, or keep as string
                if value.lower() in ['true', 'false']:
                    value = value.lower() == 'true'
                elif value.replace('.', '').isdigit():
                    value = float(value) if '.' in value else int(value)
                
                target[keys[-1]] = value
                
                if save_config(config):
                    print(f"Set {key} = {value}")
                else:
                    print("Failed to save configuration")
            else:
                print("Usage: kfg config [set key value]")
        elif cmd == "help":
            print("Usage:")
            print("  kfg           - Start daemon with terminal selection")
            print("  kfg trigger   - Send trigger to running daemon")
            print("  kfg last-line - Get last line from selected terminal")
            print("  kfg add       - Add kfg hook to Claude settings")
            print("  kfg config    - Show current configuration")
            print("  kfg config set key value - Set configuration value")
            print("  kfg stop      - Stop running daemon")
            print("  kfg status    - Show daemon status")
            print("  kfg help      - Show this help")
        else:
            print(f"Unknown command: {cmd}")
            print("Run 'kfg help' for usage information")
        return
    
    # Main flow - start daemon
    if is_daemon_running():
        print("kfg daemon is already running")
        print("Use 'kfg trigger' to send trigger or 'kfg stop' to stop")
        return
    
    windows = get_terminal_windows()
    if not windows:
        return
    
    selected_idx = select_terminal_window(windows)
    if selected_idx is None:
        return
    
    print(f"\nSelected: {windows[selected_idx]}")
    print("Starting daemon...")
    
    start_daemon(selected_idx)


if __name__ == "__main__":
    main()